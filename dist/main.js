/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/characters.js":
/*!***************************!*\
  !*** ./src/characters.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("//sheet has 15 image columns and 5 image rows it 720px length and 267height each is 48px wide by 48px height\n//\nconst DIRECTIONS = [\"N\",\"S\",\"E\",\"W\"]\nconst inflectionY = [-30,250,425,430,535];\nconst inflectionX = [-15, 290, 355, 430, 490, 635, 780, 905, 980, 1050];\nconst humanUnits = [\"Archer\",\"Brigand\",\"Catapult\",\"Cleric\",\"Conjurer\",\"Peasant\",\"Conjurer\",\"Lothar\"];\nconst orcUnits = [\"Necrolyte\",\"Ogre\",\"Grunt\",\"Raider\",\"Skeleton\",\"Spearman\",\"Medivh\",\"Warlock\",\"GaronaGriselda\"];\nconst allBad=[\"Spider\",\"Daemon\",\"Scorpion\"];\nconst conjured=[\"Spider\",\"Daemon\",\"Scorpion\",\"Skeleton\",\"Slime\",\"WaterElemental\",\"FireElemental\"];\nconst working=[\"Daemon\",\"Skeleton\"];\n\nconst Sound = __webpack_require__(/*! ./sound */ \"./src/sound.js\");\n\n\nfunction Character(characterName, health, game, startX = -10, startY = 250, speedMulty = 1, radius = 25) {\n    //this.sheetname = 'Daemon.png'\n    this.sheetname = working[Math.floor(Math.random()*working.length)];\n    //console.log(this.sheetname);\n    this.board = game;\n    //console.log(this.board);\n    this.character = new Image();\n    this.character.src = `../assets/sprites/${this.sheetname}.png`;\n    this.gridCell;\n\n    this.dyingSound = new Sound('../assets/dying.mp3');\n\n    this.radius = radius;\n\n    this.x = startX;\n    this.y = startY;\n\n    this.srcX;\n    this.srcY;\n\n    this.sheetWidth;// = 720;\n    this.sheetHeight;// = 240;\n\n\n    this.cols;// = 15;\n    this.rows;// = 5;\n\n    this.east = 2;\n    this.north = 0;\n    this.south = 4; \n    this.west = 2; \n\n    this.currentFrame = 0;\n\n    this.health = 100;\n    this.value = 100;\n    this.damage = 10;\n    if (this.sheetname === \"Skeleton\"){\n        // skeleton sheet 640 * 187 \n        // 20 columns\n        this.sheetWidth = 600;\n        this.sheetHeight = 150;\n        this.cols = 20;\n        this.rows = 5;  \n        this.health = 100;\n        this.value = 100;\n        this.damage = 25;\n    }else if (this.sheetname === \"Spider\"){\n        // console.log(\"In spider\")\n        // skeleton sheet 640 * 187 \n        // 20 columns\n        this.sheetWidth = 480;\n        this.sheetHeight = 1157;\n\n        this.cols = 5;\n        this.rows = 15;\n\n        this.east = 2;\n        this.north = 0;\n        this.south = 4; \n        this.west = 2; \n    }else if(this.sheetname === \"Daemon\"){\n        this.sheetWidth = 720;\n        this.sheetHeight = 240;\n\n        this.cols = 15;\n        this.rows = 5;\n\n        this.east = 2;\n        this.north = 0;\n        this.south = 4; \n        this.west = 2; \n\n        this.health = 500;\n        this.value = 400;\n        this.damage = 100;\n    }\n\n    this.speed = Math.floor((Math.random()*5*speedMulty)+1);\n    this.size = 1.25;\n\n    this.width = this.sheetWidth/this.cols;\n    this.height = this.sheetHeight/this.rows;\n    this.canChangeDirection = true;\n\n    this.direction = \"E\"; ///\"N\" \"W\" \"S\"\n    //console.log(this);\n\n    // this.health = 100;\n\n    this.currentGridLocation = this.board.grid[0][10];\n    this.currentGridLocationCenterForTakingFire = this.currentGridLocation.center;\n\n    //console.log(this.board.home)\n}\n\nCharacter.prototype.changeDirection = function(directions = DIRECTIONS){\n    this.direction = directions[Math.floor(Math.random()*directions.length)];\n}\n\nCharacter.prototype.setAnimationSheetInfo = function(){\n    if (this.sheetname === \"Skeleton\"){\n        // skeleton sheet 640 * 187 \n        // 20 columns\n        this.sheetWidth = 600;\n        this.sheetHeight = 150;\n        this.cols = 20;\n        this.rows = 5;  \n    }else if (this.sheetname === \"Spider\"){\n        // skeleton sheet 640 * 187 \n        // 20 columns\n        this.sheetWidth = 480;\n        this.sheetHeight = 160;\n        this.cols = 5;\n        this.rows = 15;\n        this.east = 2;\n        this.north = 0;\n        this.south = 4  \n    }\n}\n\n\nCharacter.prototype.whichDirection = function(){\n    if (this.x < -15){\n        this.direction = \"E\";\n    }else if (this.x > 1180){\n        this.x = 1160\n        this.direction = \"W\";\n    }else if (this.y > 535){\n        this.direction = \"N\";\n    }else if (this.y < -30){\n        this.direction = \"S\";\n    }\n    this.currentGridLocation.col = Math.floor((this.x)/30);\n    this.currentGridLocation.row = Math.floor((this.y)/30);\n    let smallestNeighbor = this.board.grid[this.currentGridLocation.col][this.currentGridLocation.row].smallestNeighbor;\n\n    if( this.currentGridLocation.col < smallestNeighbor.j){\n        this.direction = \"E\";\n    }else if(this.currentGridLocation.col > smallestNeighbor.j){\n        this.direction = \"W\";\n    }else if(this.currentGridLocation.row < smallestNeighbor.i){\n        this.direction = \"S\";\n    }else if(this.currentGridLocation.row > smallestNeighbor.i){\n        this.direction = \"N\";\n    }\n\n    // if smallestNeighbor === \n    //console.log(this.direction);\n\n}\n\nCharacter.prototype.getGridCenter = function(ctx) {\n    this.currentGridLocation.col = Math.floor((this.x)/30);\n    this.currentGridLocation.row = Math.floor((this.y)/30);\n\n    //console.log(this.board.grid[this.currentGridLocation.col][this.currentGridLocation.row]);\n    if (this.board.grid[this.currentGridLocation.col][this.currentGridLocation.row]) this.center = this.board.grid[this.currentGridLocation.col][this.currentGridLocation.row].center; \n    // this.center = this.board.grid[this.currentGridLocation.col][this.currentGridLocation.row].center || {x:0,y:0};\n\n}\n\nCharacter.prototype.updateFrame = function(ctx) {\n    this.getGridCenter();\n    this.characterDead();\n    this.whichDirection();\n    this.currentFrame = ++this.currentFrame%this.rows;\n    this.srcY = this.currentFrame * this.height;\n    switch (this.direction) {\n        case \"E\":\n            this.srcX = this.width*this.east;//2\n            break;\n        case \"N\":\n            this.srcX = this.width*this.north;//0\n            break;\n        case \"S\":\n            this.srcX = this.width*this.south;//4\n            break;\n        case \"W\":\n            this.srcX = this.width*this.west;//2\n            break;\n        default:\n            break;\n    }\n\n    if (this.direction === \"E\"){\n        this.x += this.speed;\n    }else if (this.direction === \"W\"){\n        this.x -= this.speed;\n    }else if (this.direction === \"N\"){\n        this.y -= this.speed;\n    }else if (this.direction === \"S\"){\n        this.y += this.speed;\n    }\n    \n}\n\nCharacter.prototype.draw = function(game){\n    \n    let ctx = game.ctx;\n\n    this.updateFrame(ctx);\n    if (this.direction === \"W\"){\n        ctx.save();\n        ctx.scale(-1,1);\n        ctx.drawImage(this.character, this.srcX, this.srcY, this.width, this.height, -this.x, this.y, this.width*this.size, this.height*this.size)\n        ctx.restore();\n    }else{\n        ctx.drawImage(this.character, this.srcX, this.srcY, this.width, this.height, this.x, this.y, this.width*this.size, this.height*this.size)\n    }\n}\n\nCharacter.prototype.characterDead = function(){\n    let homeBase = {row: this.board.home.i, col: this.board.home.j};\n    let hRow = this.board.home.i;\n    let hCol = this.board.home.j;\n    let cRow = this.currentGridLocation.row;\n    let cCol = this.currentGridLocation.col;\n    //console.log(homeBase)\n    if ((hRow-cRow < 2 && hCol-cCol < 2)){\n        //console.log(\"baddy made to home tower character\")\n        this.board.health -= this.damage;\n        this.board.remove(\"baddy\",this);\n        //console.log(this.board.health);\n    }\n    if (this.health < 1){\n        //console.log(\"Character was blasted off of screen\")\n        this.dyingSound.play();\n        this.board.bank += this.value;\n        this.board.health += 10;\n        this.board.currentScore += 10;\n        this.board.baddiesDefeated += 1;\n        this.board.remove(\"baddy\",this);\n    }\n}\n\nCharacter.prototype.collided = function(otherObject){\n    // console.log(this.center);\n    // console.log(otherObjects)\n\n}\n\nCharacter.prototype.collideWith = function(otherObject) {\n    if (otherObject instanceof Projectile) {\n      this.health -= 50;\n      return true;\n    }\n    return false;\n  },\n\nmodule.exports = Character;\n\n\n\n\n\n\n\n\n\n\n\n\n// let sheetname = 'Daemon.png'\n\n// let character = new Image();\n// character.src = \"../assets/sprites/Daemon\"\n\n// let x = 0;\n// let y = 0;\n\n// let srcX;\n// let srcY;\n\n// sheetWidth = 720;\n// sheetHeight = 240;\n\n// let cols = 15;\n// let rows = 5;\n\n// let width = sheetWidth/cols;\n// let height = sheetHeight/rows;\n\n// let currentFrame = 0;\n\n//# sourceURL=webpack:///./src/characters.js?");

/***/ }),

/***/ "./src/graph_cell.js":
/*!***************************!*\
  !*** ./src/graph_cell.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const WALKING_PATH_IDS = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 30, 31, 32, 33, 34, 35, 36, 37, 40, 41, 50, 51, 52, 56, 57, 60, 61, 70, 71, 76, 77, 80, 81, 90, 91, 96, 97, 100, 101, 110, 111, 116, 117, 120, 121, 130, 131, 136, 137, 140, 141, 150, 151, 156, 157, 160, 161, 170, 171, 176, 177, 180, 181, 190, 191, 196, 197, 200, 201, 210, 211, 216, 217, 218, 219, 220, 221, 230, 231, 236, 237, 238, 239, 240, 241, 250, 251, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 280, 281, 290, 300, 301, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 330, 334, 335, 340, 341, 350, 354, 355, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 374, 375, 380, 381, 390, 394, 395, 400, 401, 410, 414, 415, 420, 421, 430, 434, 435, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 454, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 474, 475, 480, 481, 490, 494, 495, 500, 501, 510, 514, 515, 520, 521, 530, 534, 535, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 554, 555, 560, 561, 570, 574, 575, 580, 581, 590, 594, 595, 600, 601, 610, 614, 615, 620, 621, 630, 634, 635, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 670, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 699, 700, 701, 702, 710, 719, 720, 721, 722, 730, 739, 740, 741, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 770, 781, 790]\n\nfunction GraphCell(board, id, i, j) {\n    this.id = id;\n    this.board = board;\n    this.cellWidth = this.board.cellWidth;\n    this.location = {x: i*this.cellWidth ,y: j*this.cellWidth}\n    this.center = {x: this.location.x + 1/2*this.cellWidth, y: this.location.y + 1/2*this.cellWidth}\n    this.parentNode = \"\";\n    this.context = this.board.ctx;\n\n    //Currently flipped becuase in game we created colums first and populated them\n    this.i = j;\n\tthis.j = i;\n\n\tthis.f = 0; \n\tthis.g = 0;\n\tthis.h = 0;\n\n    this.neighbors = [];\n    this.smallestNeighbor;\n    this.directionFromNearestNeighbor = \"E\";\n\tthis.previous = undefined;\n    this.shortestPath = [];\n    \n    if (WALKING_PATH_IDS.includes(this.id)){\n        this.walkingPath = true;\n    }else{\n        this.walkingPath = false;\n    }\n\tthis.wall = false;\n\tthis.startingArea = false;\n\tthis.isTower = false;\n    this.pathScore = -1;\n    this.nodeAvailable = true;\n}\n\n\n\n\nGraphCell.prototype.addNeighbors = function(){\n\n    let col = this.j;\n    let row = this.i;\n    let grid = this.board.grid;\n\n    if(row > 0 && !this.wall && !grid[col][row-1].wall){\n        this.neighbors.push(grid[col][row-1]);\n    }\n    if(col < grid.length-1 && !this.wall && !grid[col+1][row].wall){\n        this.neighbors.push(grid[col+1][row]);\n    }\n    if(row < grid[col].length-1 && !this.wall && !grid[col][row+1].wall){\n        this.neighbors.push(grid[col][row+1]);\n    }\n    if(col > 0 && !this.wall && !grid[col-1][row].wall){\n        this.neighbors.push(grid[col-1][row]);\n    }\n}\n\n\n// GraphCell.prototype.addNeighbors = function(){\n\n//     let col = this.j;\n//     let row = this.i;\n//     let grid = this.board.grid;\n\n//     if(row > 0 && !this.wall && !grid[col][row-1].wall){\n//         this.neighbors.push(grid[col][row-1]);\n//     }\n//     if(col < grid.length-1 && !this.wall && !grid[col+1][row].wall){\n//         this.neighbors.push(grid[col+1][row]);\n//     }\n//     if(row < grid[col].length-1 && !this.wall && !grid[col][row+1].wall){\n//         this.neighbors.push(grid[col][row+1]);\n//     }\n//     if(col > 0 && !this.wall && !grid[col-1][row].wall){\n//         this.neighbors.push(grid[col-1][row]);\n//     }\n// }\n\nGraphCell.prototype.render = function(){\n    if (this.wall){\n        this.context.fillStyle = \"#8c1d35\";\n    }else{\n        this.context.fillStyle = \"rgba(66,245,179, 0.25)\";\n    }\n    this.context.strokeStyle = \"#2e5244\";\n    this.context.fillRect(this.location.x, this.location.y, this.cellWidth, this.cellWidth);\n    this.context.strokeRect(this.location.x, this.location.y, this.cellWidth, this.cellWidth);\n    this.context.font = \"10px Arial\";\n    this.context.fillStyle=\"#000000\";\n    this.context.fillText(this.pathScore,this.location.x+5,this.location.y+15);\n\n}\n\nGraphCell.prototype.getLeastNeighborPath = function(){\n    let smallestScore = 64000;\n    this.neighbors.forEach((flanders,idx) => {\n        if(flanders.pathScore < smallestScore){\n            smallestScore = flanders.pathScore;\n            this.smallestIdx = idx;\n        }\n    })\n\n    this.smallestNeighbor = this.neighbors[this.smallestIdx];\n}\n\nmodule.exports = GraphCell;\n\n\n\n\n\n\n// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800]\n\n\n//# sourceURL=webpack:///./src/graph_cell.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nconst Tower = __webpack_require__(/*! ./tower */ \"./src/tower.js\");\nconst Character = __webpack_require__(/*! ./characters */ \"./src/characters.js\")\nconst GraphCell = __webpack_require__(/*! ./graph_cell */ \"./src/graph_cell.js\");\nconst Projectile = __webpack_require__(/*! ./projectile */ \"./src/projectile.js\");\nconst Sound = __webpack_require__(/*! ./sound */ \"./src/sound.js\");\n\nlet game;\n//\nlet fps = 20;\nlet now;\nlet then = Date.now();\nlet interval = 1000/fps;\nlet delta;\nlet soundTrack;\nlet startGame = false;\nlet enemyType = \"orcs\";\n\n\n\n\n\n\n//Buttons on the start screan, other le\nlet chooseDestiny = function(){\n  // modal logic\n  document.getElementById(\"start-game\").addEventListener(\"click\", function() {\n    document.getElementById('game-modal').style.display='none';\n    window.setTimeout(initialize, 100);\n  });\n\n  document.getElementById(\"human\").addEventListener(\"click\", function() {\n    enemyType = \"orcs\";\n;\n\n  });\n\n\n  \n\n\n}\n\nlet initialize = function(){\n  game = new Game(enemyType);\n  window.setTimeout(animation, 200);\n}\n\nif (startGame){\n  window.setTimeout(animation, 200);\n}\n\nlet animation = function(){\n  window.requestAnimationFrame(animation);\n  \n  now = Date.now();\n  delta = now - then;\n  \n  if (delta > interval && game.gameOn) {\n    \n    then = now - (delta % interval);\n    game.run();\n  }\n}\n\nlet mousePos = {x: -60, y: -60};\nwindow.addEventListener('mousemove',(event)=>{\n  mousePos.x = event.x;\n  mousePos.y = event.y;\n  //console.log(mousePos)\n})\n\nclass Game {\n  constructor(baddiesType = \"orcs\"){\n    this.gameOn = true;\n\n    this.tiles = []\n    this.towers = [];\n    this.baddies = [];\n    this.projectiles = [];\n    this.grid = []\n    \n    \n    //stats\n    this.currentScore = 0;\n    this.bank = 1000;\n    this.score= 0;\n    this.currentHealth = 100;\n    this.health = 100;\n    this.currWave = 0;\n    this.baddiesDefeated = 0;\n    this.displayNeedCoins = false;\n    this.noCoinsFrames = 40;\n\n\n    this.boardImg = new Image();\n    this.boardImg.src = `../assets/sprites/game_board_01.png`;\n    //dynamic homebase \n    this.homeImg = new Image();\n    this.homeImg.src = `../assets/sprites_towers/home_against_${baddiesType}.png`;\n    \n    this.waveAmount = 5;\n    this.baddiesType = baddiesType; \n    \n\n    //Towers are created Dynamically and set on the canvas\n    this.towerSelected = false;\n    this.towerSelectors = this.createTowerSelectors();\n    this.setTowerFunctions(this.towerSelectors);\n    this.createGameStats();\n\n    window.game = this;\n\n    this.board = document.createElement(\"canvas\");\n    if(!this.board || !this.board.getContext){\n      throw \"Issues with Canvas or Board\"\n    }\n    this.board.width = 1200;\n    this.board.height = 600;\n    document.getElementById(\"canv\").appendChild(this.board);\n\n    // this.board.soundTrack = new Sound('../assets/soundTrack.mp3');\n\n    //event listeners\n    this.board.addEventListener('mousemove', this.handleBoardMouseMoved, false)\n    this.board.addEventListener('mouseover', this.handleBoardMouseOver, false)\n    this.board.addEventListener('click', this.handleBoardMouseClick, false)\n    this.board.newSound = new Sound('../assets/soundTrack.mp3');\n\n    this.ctx = this.board.getContext(\"2d\");\n    if(!this.ctx){\n      throw \"invalid context\";\n    }\n\n    this.cellWidth = 30;\n    this.gridCols = this.board.width/this.cellWidth;\n    this.gridRows = this.board.height/this.cellWidth;\n    this.playMusic = this.playMusic.bind(this);\n    this.createGrid();\n    this.playMusic();\n  }\n\n  \n  run(){\n    if(this.health < 1) this.gameOver();\n    this.updateStats();\n    this.render(this.ctx);\n    this.collisionDetection();\n    if (this.baddies.length<1){\n      this.endOfRoundLogic();\n      //console.log(this.bank);\n    }\n    if (this.health < 1){\n      console.log(\"Game Over\")\n    }\n  }\n\n  \n  render(ctx){\n      \n      ctx.clearRect(0,0,this.board.width,this.board.height);\n      //The Board\n      // ctx.drawImage(this.tile, this.srcX, this.srcY, this.width, this.height, this.x, this.y, this.width*6, this.height*9)\n      ctx.drawImage(this.boardImg, 0, 0, this.board.width, this.board.height, 0, 0, this.board.width, this.board.height)\n      ctx.drawImage(this.homeImg, 1100, 255);\n\n        //Put Baddies on the board\n        for (let i = 0; i < this.baddies.length; i++) {\n          const baddy= this.baddies[i];\n          //console.log(baddy);\n          baddy.draw(this)\n          \n        }\n        \n        //Put towers on the board\n        for (let t = 0; t < this.towers.length; t++) {\n          const tower = this.towers[t];\n          //console.log(baddy);\n          tower.run(this);\n          \n        }\n\n        //Put projectiles on the board\n        for (let p = 0; p < this.projectiles.length; p++) {\n          const projectile = this.projectiles[p];\n          //console.log(baddy);\n          projectile.run(this);\n          \n        }\n\n\n        //The Path Grid only shown for testing purposes\n        for (let col = 0; col < this.gridCols; col++) {\n            for (let row = 0; row < this.gridRows; row++) {\n                //console.log(col,row);\n                // this.grid[col][row].render();\n            }   \n        }\n        \n      // console.log(this.noCoinsFrames)\n      if(this.displayNeedCoins){\n        console.log(\"displaying lack of coins\")\n        ctx.font = \"60px Yeon Sung\";\n        ctx.fillStyle = \"red\";\n        ctx.textAlign = \"center\";\n        ctx.fillText(\"Need More Coins!\", this.board.width/2, this.board.height/2); \n        \n      }\n        \n  }\n\n  playMusic(){\n  }\n\n    //Gets the amount of bank left\n  getBank(){\n    return this.bank;\n  }\n\n\n\n    collisionDetection(){\n      for (let i = 0; i < this.projectiles.length; i++) {\n        for (let k = 0; k < this.baddies.length; k++) {\n          let element1 = this.projectiles[i];\n          let element2 = this.baddies[k];\n          if (element1.collided(element2)){\n            let collision  = element1.collideWith(element2);\n            return collision;\n          }\n        }\n      }\n    }\n\n\n    //Tower Display, Selection and Dropping\n    setTowerFunctions(towerSelectorsArray){\n      let instance = this;\n      towerSelectorsArray.forEach((tower, i)=>{\n        tower.addEventListener('mouseover',this.selectorHoverOn, false)\n        tower.addEventListener('mouseout',this.selectorHoverOff, false)\n        tower.addEventListener('mousedown',this.selectorPressed, false)\n        tower.addEventListener('click',this.selectorClick, false)\n      })\n    }\n\n    selectorHoverOn(){\n      this.style.backgroundImage = 'radial-gradient(green, brown)';\n    }\n    selectorHoverOff(){\n      this.style.backgroundImage = 'radial-gradient(brown, green)';\n\n    }\n    selectorPressed(){\n      this.style.backgroundColor = 'Red';\n    }\n    selectorClick(){\n      console.log(this)\n      this.style.backgroundColor = 'green';\n      if (game.towerSelected === true) return;\n      if (game.getBank() > this.cost){\n        console.log(\"bank was enough\")\n        game.createTower(this);\n        game.towerSelected = true;\n      }else{\n        game.displayNeedCoins = true;\n        console.log(\"not enough cheddar\")\n        // console.log(console.log(game))\n        setTimeout(()=>{\n          game.displayNeedCoins = false;\n        },1000);\n      }\n    }\n\n\n    createTower(selector){\n    \n      \n      let tower = new Tower(selector.cost, selector.tImage, selector.bImage, game);\n      if (tower){\n        console.log(tower);\n        this.towers.push(tower);\n      } else {\n        console.log(\"there was a problem with tower\")\n      }\n  \n    }\n\n\n    createTowerSelectors(){\n      console.log(\"in index.js\")\n      let TowerSelectors = [];\n      for (let i = 0; i < 5; i++) {\n        let tSelector = document.createElement(\"div\");\n        let tSelectedImgPath = `../assets/sprites_towers/tower_against_${this.baddiesType}_0${i+1}.png`;\n        let tSelectedBulletImgPath = `../assets/sprites_bullets/B${i+1}.png`;\n  \n  \n        tSelector.tImage = new Image();\n        tSelector.tImage.addEventListener('load',this.hideImgElement,false);\n        tSelector.tImage.addEventListener('error', ()=>{console.log(\"fail tower\");}, false);\n        tSelector.tImage.src = tSelectedImgPath;\n  \n        tSelector.bImage = new Image();\n        tSelector.bImage.addEventListener('load',this.hideImgElement,false);\n        tSelector.bImage.addEventListener('error', ()=>{console.log(\"fail bullet\");}, false);\n        tSelector.bImage.src = tSelectedBulletImgPath;\n  \n        document.getElementById(\"playables\").append(tSelector)\n  \n        tSelector.cost = 50*i*5+50;\n        tSelector.id = \"tSel\"+i;\n        tSelector.style.cursor = \"url(../assets/hammer.png),pointer\";\n        TowerSelectors.push(tSelector);\n        let selectorImagePath= `../assets/sprites_towers/tower_against_${this.baddiesType}_0${i+1}.png`;\n        let selectorImage = new Image();\n        selectorImage.addEventListener('error', ()=>{console.log(\"fail selector\");}, false);\n        selectorImage.src = selectorImagePath;\n\n        tSelector.appendChild(selectorImage);\n\n\n        let tCost = document.createTextNode(`${tSelector.cost}`);\n        let tCostDiv = document.createElement(\"div\");\n        tCostDiv.className = \"costs-divs\";\n        tCostDiv.append(tCost);\n\n\n\n        \n        // statsHolder.append(document.createElement(\"BR\"))\n        // statsHolder.append(htmlInner)\n        // statsHolder.innerHTML = htmlInner;\n        // statsHolder.className = \"stats-divs\";\n        // statsHolder.id = statsTypesArr[i];\n        // document.getElementById(\"stats\").append(statsHolder)\n\n\n\n        // myimg.insertAdjacentHTML(\"afterend\", \"This is my caption.\");\n        \n        \n        // document.createElement(\"div\");\n        // tCost.innerHTML = \"100\";\n        \n        \n        \n\n        document.getElementById(`${tSelector.id}`).appendChild(tCostDiv); \n\n        //tSelector.append(tCostDiv);\n        \n      }\n  \n  \n      return TowerSelectors;\n    }\n\n    createGameStats(){\n      let GameStats = [];\n      let statsTypesArr = [\"health\",\"bank\",\"wave\",\"enemiesLeft\",\"total-killed\"];\n      let htmlInner;\n      let statTitle;\n      for (let i = 0; i < 5; i++) {\n        switch (statsTypesArr[i]) {\n          case \"health\": \n          statTitle = document.createTextNode(\"Health\");\n          htmlInner = this.health;\n          break;\n\n          case \"bank\":\n            statTitle = document.createTextNode(\"Bank\");\n            htmlInner = this.bank;\n          break;\n\n          case \"wave\":\n            statTitle = document.createTextNode(\"Wave\");\n            htmlInner = this.currWave;\n          break;\n\n          case \"enemiesLeft\":\n            statTitle = document.createTextNode(\"Enemies\");\n            htmlInner = this.baddies.length;\n          break;\n\n          case \"total-killed\":\n            statTitle = document.createTextNode(\"Dead\");\n            htmlInner = this.baddiesDefeated;\n          break;\n        \n          default:\n          break;\n        }\n        let statsHolder = document.createElement(\"div\");\n        statsHolder.append(statTitle)\n        statsHolder.append(document.createElement(\"BR\"))\n        statsHolder.append(htmlInner)\n        // statsHolder.innerHTML = htmlInner;\n        statsHolder.className = \"stats-divs\";\n        statsHolder.id = statsTypesArr[i];\n        document.getElementById(\"stats\").append(statsHolder)\n      \n      }\n      // this.updateStats();\n      // console.log(\"done creating stats divs\")\n      return GameStats;\n    }\n\n    updateStats(){\n      let statsTypesArr = [\"health\",\"bank\",\"wave\",\"enemiesLeft\",\"total-killed\"]\n      let statsDivs = document.getElementById('stats').getElementsByClassName('stats-divs');\n      for (let i = 0; i < statsDivs.length; i++) {\n        const stat = statsDivs[i];\n        // console.log(statsDivs)\n        switch (stat.id) {\n          case \"health\":\n            stat.innerHTML = `Health<br>${this.health}`\n          break;\n\n          case \"bank\":\n            if(game.displayNeedCoins){\n              stat.style.color = 'red';\n              stat.innerHTML = `Bank<br>${this.bank}`\n            }else{\n              stat.style.color = 'wheat';\n              stat.innerHTML = `Bank<br>${this.bank}`\n            }\n          break;\n\n          case \"wave\":\n            stat.innerHTML = `Wave<br>${this.currWave}`\n          break;\n\n          case \"enemiesLeft\":\n            stat.innerHTML = `Enemies<br>${this.baddies.length}`\n          break;\n\n          case \"total-killed\":\n            stat.innerHTML = `Dead<br>${this.baddiesDefeated}`\n          break;\n        \n          default:\n            break;\n        }\n        \n      }\n    }\n\n    //Game logic to add towers to canvas\n    handleBoardMouseMoved(event){\n      game.mouseX = event.offsetX;\n      game.mouseY = event.offsetY;\n      this.mouseX = event.offsetX;\n      this.mouseY = event.offsetY;\n      if(game.towers.length < 1) return;\n      if(!game.towers[game.towers.length-1].placed && game.towerSelected === true){\n        game.towers[game.towers.length-1].location.y = this.mouseY;\n        game.towers[game.towers.length-1].location.x = this.mouseX;\n      }\n    }\n  \n    handleBoardMouseOver(){\n        if(game.towers.length < 1) return;\n        game.towers[game.towers.length-1].shouldDraw = true;\n    }\n  \n    handleBoardMouseClick(event){\n      //console.log(event);\n      let row = Math.floor(event.offsetY/game.cellWidth);\n      let col = Math.floor(event.offsetX/game.cellWidth);\n      let node = game.grid[col][row];\n      // console.log(node)\n      \n      if(game.towerSelected && game.nodeAvailable(node)){\n        game.putTower(node);\n        game.bank -= game.towers[game.towers.length-1].cost;\n      }\n\n      else if(!game.towerSelected && !node.hasTower) {\n          // putting walls on the board\n          if (!node.wall && game.getBank() >= game.wallVal){\n              game.bank -= game.wallVal;\n              node.wall = true;\n          } else if(!node.wall) {\n              // alert(\"Not Enough Dinero\");  \n              }\n          else {\n              game.bank += game.wallVal;\n              node.wall = false;\n          }\n          //game.brushfire(game.undo(node));   // all new distances and parents\n        }\n    }\n\n    nodeAvailable(node) {\n\n      // add conditions before allowing user to place turret\n      // Some money required but also cannot place tower on a node\n      // of the grid that is occupied or is the root node\n      if(game.towerSelected) {\n          if(!node.wall && !node.isTower && node != game.home){\n            return true;\n          }\n        return(false);\n      }\n    }\n\n\n    putTower(node){\n      // console.log(\"Testing\");\n      // console.log(node)\n        game.towers[game.towers.length-1].location = {\n          x: ((node.j*this.cellWidth)+this.cellWidth/2),\n          y: ((node.i*this.cellWidth)+this.cellWidth/2)\n        };\n\n        game.towers[game.towers.length-1].placed = true;\n        node.isTower = true;\n        game.towerSelected = false;\n\n    }\n\n    //Wave Logic including brushfire grid and baddy generation\n    createGrid(){\n        let id = 0\n        for (let i = 0; i < this.gridCols; i++) {\n          this.grid.push([]);\n          for (let j = 0; j < this.gridRows; j++) {\n              this.grid[i].push(new GraphCell(this,++id, i, j))\n          }\n  \n        }\n\n\n      for (let col = 0; col < this.gridCols; col++) {\n            for (let row = 0; row < this.gridRows; row++) {\n                //console.log(col,row);\n                this.grid[col][row].addNeighbors();\n            }   \n        }\n\n        this.home = this.grid[this.gridCols-1][this.gridRows/2];\n        this.home.wall = false;\n        this.home.pathScore = 0;\n\n        this.createPaths();\n    }\n\n    getGridLocationCEnter(i,j){\n\n    }\n\n\n    createPaths(){\n        //I will be using the brushfire design with end goal in mind\n        let checkFifo = [this.home];\n        while (checkFifo.length > 0){\n            let currentCell = checkFifo.shift();\n            currentCell.neighbors.forEach(flanders => {\n                if (flanders.pathScore === -1){\n                    checkFifo.push(flanders); \n                    flanders.pathScore = currentCell.pathScore+30;\n                }\n            })\n        }\n\n\n        for (let col = 0; col < this.gridCols; col++) {\n            for (let row = 0; row < this.gridRows; row++) {\n                //console.log(col,row);\n                if(!this.grid[col][row].wall){\n                    this.grid[col][row].getLeastNeighborPath();\n                }\n            }   \n        }\n    }\n\n\n  endOfRoundLogic(){\n    this.waveAmount = Math.floor(this.waveAmount*1.20);\n    this.currWave += 1;\n    this.generateNextWave();\n  }\n\n  generateNextWave(){\n    this.board.newSound.stop();\n    // console.log(this.board.newSound)\n    this.board.newSound.play();\n\n    for (let i = 0; i < this.waveAmount; i++) {\n        let newX = 0;\n        let newY = Math.floor(Math.random()*600);\n      let newBaddy = new Character(0,0,this,newX, newY);\n      this.baddies.push(newBaddy);\n      // this.board.soundTrack.play();\n    }\n  }\n  \n\n  remove(objectType, item){\n    if (objectType === \"projectile\"){\n      this.projectiles.splice(this.projectiles.indexOf(item), 1);\n    }else if (objectType === \"baddy\"){\n      this.baddies.splice(this.baddies.indexOf(item), 1);\n    }\n  }\n\n  gameOver(){\n    game.gameOn = false;\n    console.log(\"in game over function\")\n    document.getElementById('game-on').style.display='none';\n    document.getElementById('end-modal').style.display='block';\n  }\n  \n  \n}\n\n\n// window.addEventListener('load', initialize, false);\nwindow.addEventListener('load', chooseDestiny, false);\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/projectile.js":
/*!***************************!*\
  !*** ./src/projectile.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nconst Character = __webpack_require__(/*! ./characters */ \"./src/characters.js\");\n\nlet Projectile = function(location, enemyOrientationAngle, prjImg, velocity = 6, game, damage = 25, radius = 25, ){\n    this.location = location;\n    this.enemyOrientationAngle = enemyOrientationAngle;\n    this.prjImg = prjImg;\n    this.velocity = velocity;\n    this.game = game;\n    this.radius = radius;\n    this.damage = damage\n    \n\n}\n\nProjectile.prototype = {\n    run:function(){\n        this.update();\n        this.draw();\n    },\n    \n    update:function(){\n        this.isOutOfBounds();\n        this.location.x += Math.sin(this.enemyOrientationAngle)*this.velocity;\n        this.location.y += Math.cos(this.enemyOrientationAngle)*this.velocity;\n\n    },\n    \n    draw:function(){\n        this.game.ctx.save();\n        this.game.ctx.translate(this.location.x,this.location.y);\n        this.game.ctx.rotate(this.enemyOrientationAngle);\n        this.game.ctx.drawImage(this.prjImg, -this.prjImg.width/2, -this.prjImg.height/2)\n        this.game.ctx.restore();\n\n    },\n\n    \n    isOutOfBounds:function(){\n        let height = this.game.ctx.canvas.height;\n        let width = this.game.ctx.canvas.width;\n        \n        if (this.location.x < 0 || this.location.y < 0 || this.location.x > width || this.location.y > height){ \n            this.game.remove(\"projectile\",this)\n        };\n    },\n    \n    collided:function(otherObject){\n        let distance = this.findDist(otherObject.center,this.location)\n        return (this.radius + otherObject.radius) > distance;\n\n    },\n\n    collideWith:function(otherObject) {\n        if (otherObject instanceof Character) {\n          otherObject.health -= this.damage;\n          this.game.remove(\"projectile\",this)\n          return true;\n        }\n        return false;\n    },\n\n    findDist:function(pos1, pos2) {\n        return Math.sqrt(\n          Math.pow(pos1.x - pos2.x, 2) + Math.pow(pos1.y - pos2.y, 2)\n        );\n    }\n      \n\n}\n\nmodule.exports = Projectile;\n\n\n//# sourceURL=webpack:///./src/projectile.js?");

/***/ }),

/***/ "./src/sound.js":
/*!**********************!*\
  !*** ./src/sound.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n\nfunction Sound(src){\n    this.sound = document.createElement(\"audio\");\n    this.sound.src = src;\n    this.sound.setAttribute(\"preload\", \"auto\");\n    this.sound.setAttribute(\"controls\", \"none\");\n    this.sound.style.display = \"none\";\n    document.body.appendChild(this.sound);\n    this.play = function(){\n      this.sound.play();\n    }\n    this.stop = function(){\n      this.sound.pause();\n    }\n}\n\nmodule.exports = Sound;\n\n//# sourceURL=webpack:///./src/sound.js?");

/***/ }),

/***/ "./src/tower.js":
/*!**********************!*\
  !*** ./src/tower.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Projectile = __webpack_require__(/*! ./projectile */ \"./src/projectile.js\");\nconst Sound = __webpack_require__(/*! ./sound */ \"./src/sound.js\");\n\n\nclass Tower{\n\n    constructor(cost, towerImage, projectileImg, game, loc = {x:600,y:300}, firingRange=300){\n        this.game = game;\n        this.cost = cost;\n        this.image = towerImage;\n        this.projectileImg = projectileImg;\n        this.location = loc;\n        this.enemyOrientationAngle = 0;\n        this.baddies = game.baddies;\n        this.placed = false;\n        this.shouldDraw = false;\n        this.firingRange = firingRange;\n        this.projectileSpeed = 30;\n        this.shootSound = new Sound('../assets/arrow.mp3');\n\n        this.lastFired = Date.now();\n        this.reloadTime = 500;\n        this.damage = cost;\n        this.shoot = this.shoot.bind(this);\n\n        \n    }\n\n    checkForBaddies(target){\n        let dx = this.location.x - target.x;\n        let dy = this.location.y - target.y;\n        // let ex = this.location.x - this.enemy\n\n        let distanceToTarget = Math.sqrt(Math.pow(dx,2)+Math.pow(dy,2))\n\n        if (Date.now()-this.reloadTime > this.lastFired && distanceToTarget <= this.firingRange && this.placed){\n            this.shoot();\n            this.shootSound.play();\n            this.lastFired = Date.now();\n        }\n    }\n\n    shoot(){\n        let newProj = new Projectile({x:this.location.x, y:this.location.y}, this.enemyOrientationAngle, this.projectileImg, this.projectileSpeed, this.game, this.damage)\n        this.game.projectiles.push(newProj);\n    }\n\n    run(){\n        this.update();\n        //this.checkForBaddies();\n        this.draw();\n    }\n\n    update(){\n        this.baddy = this.findBaddy()\n        let dx;\n        let dy;;\n        if (this.baddy){\n            dx = this.location.x - this.baddy.center.x;\n            dy = this.location.y - this.baddy.center.y; \n            this.target = this.baddy.center;\n            this.enemyOrientationAngle = Math.atan2(dx,dy)-Math.PI;\n\n            let distanceToTarget = Math.sqrt( Math.pow(dx, 2) + Math.pow(dy, 2) );\n            \n            if (Date.now()-this.reloadTime > this.lastFired && distanceToTarget <= this.firingRange && this.placed){\n                this.shootSound.play();\n                this.shoot();\n                this.lastFired = Date.now();\n            }\n\n        }else{\n            dx = this.location.x - this.game.mouseX;\n            dy = this.location.y - this.game.mouseY;\n            this.enemyOrientationAngle = Math.atan2(dx,dy)-Math.PI;\n        \n        }\n    }\n\n    draw(){\n        this.game.ctx.save();\n        this.game.ctx.translate(this.location.x,this.location.y);\n        if(this.shouldDraw){\n            this.game.ctx.drawImage(this.image, -this.image.width/2, -this.image.height/2)\n        }\n        this.game.ctx.restore();\n    }\n\n    findDist(pos1, pos2) {\n        return Math.sqrt(\n          Math.pow(pos1.x - pos2.x, 2) + Math.pow(pos1.y - pos2.y, 2)\n        );\n    }\n\n    findBaddy(){\n        for(let i=0;i<this.baddies.length;i++){\n        //checking center of all baddies and attacking closest one\n        let baddy = this.baddies[i]\n        let distance = this.findDist(baddy.center, this.location)\n          if(distance < this.firingRange){\n            return this.baddies[i]\n          }\n        }\n      }\n\n}\n\nmodule.exports = Tower;\n\n//# sourceURL=webpack:///./src/tower.js?");

/***/ })

/******/ });